export LANG=ja_JP.UTF-8;

# 補完機能
autoload -U compinit
compinit

# 補完メッセージを読みやすくする
# http://qiita.com/PSP_T/items/82b080920a4241e96aed
zstyle ':completion:*' verbose yes
zstyle ':completion:*' format '%B%d%b'
zstyle ':completion:*:warnings' format 'No matches for: %d'
zstyle ':completion:*' group-name ''

# コマンド履歴
HISTFILE=~/.zsh_history
HISTSIZE=6000000
SAVEHIST=6000000
setopt hist_ignore_dups     # ignore duplication command history list
setopt share_history        # share command history data

# コマンド履歴検索
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^P" history-beginning-search-backward-end
bindkey "^N" history-beginning-search-forward-end

# 補完候補を詰めて表示する
setopt list_packed

# 補完候補表示時などにピッピとビープ音をならないように設定
setopt nolistbeep

# カッコの対応などを自動的に補完する
setopt auto_param_keys

# エラーメッセージ本文出力に色付け
e_normal=`echo -e "¥033[0;30m"`
e_RED=`echo -e "¥033[1;31m"`
e_BLUE=`echo -e "¥033[1;36m"`

# 3秒以上かかった処理は詳細表示
REPORTTIME=3

if [[ -n "$TMUX" ]]; then
  cut -c3- ~/.tmux.conf | sh -s on_login
fi

autoload -Uz colors; colors

function rprompt-git-current-branch {
  local name st color

  if [[ "$PWD" =~ '/\.git(/.*)?$' ]]; then
    return
  fi
    name=$(basename "$(git symbolic-ref HEAD 2> /dev/null)")
  if [[ -z $name ]]; then
    return
  fi
  st=$(git status 2> /dev/null)
  if [[ -n $(echo "$st" | grep "^nothing to") ]]; then
    color=${fg[green]}
  elif [[ -n $(echo "$st" | grep "^nothing added") ]]; then
    color=${fg[yellow]}
  elif [[ -n $(echo "$st" | grep "^# Untracked") ]]; then
    color=${fg_bold[red]}
  else
    color=${fg[red]}
  fi

  # %{...%} は囲まれた文字列がエスケープシーケンスであることを明示する
  # これをしないと右プロンプトの位置がずれる
  echo "%{$color%}$name%{$reset_color%} "
}

# プロンプトが表示されるたびにプロンプト文字列を評価、置換する
setopt prompt_subst

RPROMPT='`rprompt-git-current-branch` %~ %{$fg_bold[blue]%}${HOST}'

function make() {
    LANG=C command make "$@" 2>&1 | sed -e "s@[Ee]rror:.*@$e_RED&$e_normal@g" -e "s@cannot¥sfind.*@$e_RED&$e_normal@g" -e "s@[Ww]arning:.*@$e_BLUE&$e_normal@g"
}
function cwaf() {
    LANG=C command ./waf "$@" 2>&1 | sed -e "s@[Ee]rror:.*@$e_RED&$e_normal@g" -e "s@cannot¥sfind.*@$e_RED&$e_normal@g" -e "s@[Ww]arning:.*@$e_BLUE&$e_normal@g"
}

#色の設定
export LSCOLORS=gxfxxxxxcxxxxxxxxxgxgx
export LS_COLORS='di=01;36:ln=01;35:ex=01;32'
zstyle ':completion:*' list-colors 'di=36' 'ln=35' 'ex=32'

# http://qiita.com/STAR_ZERO/items/860b3f141e6f7e2cc3ca
printf "\033k$(hostname -s)\033\\"

# http://qiita.com/puttyo_bubu/items/0cf94ca5a764aa22827e
if [ -f ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]; then
    source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi

source ~/github/dotfiles/zsh_local/alias

# ## tmux自動起動
# # http://d.hatena.ne.jp/tyru/20100828/run_tmux_or_screen_at_shell_startup
# is_screen_running() {
# # tscreen also uses this varariable.
#   [ ! -z "$WINDOW" ]
# }
# is_tmux_runnning() {
#   [ ! -z "$TMUX" ]
# }
# is_screen_or_tmux_running() {
#   is_screen_running || is_tmux_runnning
# }
# shell_has_started_interactively() {
#   [ ! -z "$PS1" ]
# }
# resolve_alias() {
#   cmd="$1"
#   while \
#     whence "$cmd" >/dev/null 2>/dev/null \
#     && [ "$(whence "$cmd")" != "$cmd" ]
#   do
#     cmd=$(whence "$cmd")
#   done
#   echo "$cmd"
# }
#
#
# if ! is_screen_or_tmux_running && shell_has_started_interactively; then
#   for cmd in tmux tscreen screen; do
#     if whence $cmd >/dev/null 2>/dev/null; then
#       $(resolve_alias "$cmd")
#       break
#     fi
#   done
# fi

# http://qiita.com/awakia/items/1d5cd440ce58ef4fb8ae
[ -f ~/.zshrc.local ] && source ~/.zshrc.local
